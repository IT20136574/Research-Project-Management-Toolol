(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.framesync = {}));
}(this, (function (exports) { 'use strict';

<<<<<<< HEAD
    const defaultTimestep = (1 / 60) * 1000;
    const getCurrentTime = typeof performance !== "undefined"
        ? () => performance.now()
        : () => Date.now();
    const onNextFrame = typeof window !== "undefined"
        ? (callback) => window.requestAnimationFrame(callback)
        : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);

    function createRenderStep(runNextFrame) {
        let toRun = [];
        let toRunNextFrame = [];
        let numToRun = 0;
        let isProcessing = false;
        let flushNextFrame = false;
        const toKeepAlive = new WeakSet();
        const step = {
            schedule: (callback, keepAlive = false, immediate = false) => {
                const addToCurrentFrame = immediate && isProcessing;
                const buffer = addToCurrentFrame ? toRun : toRunNextFrame;
=======
    var defaultTimestep = (1 / 60) * 1000;
    var getCurrentTime = typeof performance !== "undefined"
        ? function () { return performance.now(); }
        : function () { return Date.now(); };
    var onNextFrame = typeof window !== "undefined"
        ? function (callback) {
            return window.requestAnimationFrame(callback);
        }
        : function (callback) {
            return setTimeout(function () { return callback(getCurrentTime()); }, defaultTimestep);
        };

    function createRenderStep(runNextFrame) {
        var toRun = [];
        var toRunNextFrame = [];
        var numToRun = 0;
        var isProcessing = false;
        var toKeepAlive = new WeakSet();
        var step = {
            schedule: function (callback, keepAlive, immediate) {
                if (keepAlive === void 0) { keepAlive = false; }
                if (immediate === void 0) { immediate = false; }
                var addToCurrentFrame = immediate && isProcessing;
                var buffer = addToCurrentFrame ? toRun : toRunNextFrame;
>>>>>>> d52127c60da7f6ce492aebad9fb090b9de13f97b
                if (keepAlive)
                    toKeepAlive.add(callback);
                if (buffer.indexOf(callback) === -1) {
                    buffer.push(callback);
                    if (addToCurrentFrame && isProcessing)
                        numToRun = toRun.length;
                }
                return callback;
            },
<<<<<<< HEAD
            cancel: (callback) => {
                const index = toRunNextFrame.indexOf(callback);
=======
            cancel: function (callback) {
                var index = toRunNextFrame.indexOf(callback);
>>>>>>> d52127c60da7f6ce492aebad9fb090b9de13f97b
                if (index !== -1)
                    toRunNextFrame.splice(index, 1);
                toKeepAlive.delete(callback);
            },
<<<<<<< HEAD
            process: (frameData) => {
                if (isProcessing) {
                    flushNextFrame = true;
                    return;
                }
                isProcessing = true;
                [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
                toRunNextFrame.length = 0;
                numToRun = toRun.length;
                if (numToRun) {
                    for (let i = 0; i < numToRun; i++) {
                        const callback = toRun[i];
=======
            process: function (frameData) {
                var _a;
                isProcessing = true;
                _a = [toRunNextFrame, toRun], toRun = _a[0], toRunNextFrame = _a[1];
                toRunNextFrame.length = 0;
                numToRun = toRun.length;
                if (numToRun) {
                    for (var i = 0; i < numToRun; i++) {
                        var callback = toRun[i];
>>>>>>> d52127c60da7f6ce492aebad9fb090b9de13f97b
                        callback(frameData);
                        if (toKeepAlive.has(callback)) {
                            step.schedule(callback);
                            runNextFrame();
                        }
                    }
                }
                isProcessing = false;
<<<<<<< HEAD
                if (flushNextFrame) {
                    flushNextFrame = false;
                    step.process(frameData);
                }
=======
>>>>>>> d52127c60da7f6ce492aebad9fb090b9de13f97b
            },
        };
        return step;
    }

<<<<<<< HEAD
    const maxElapsed = 40;
    let useDefaultElapsed = true;
    let runNextFrame = false;
    let isProcessing = false;
    const frame = {
        delta: 0,
        timestamp: 0,
    };
    const stepsOrder = [
=======
    var maxElapsed = 40;
    var useDefaultElapsed = true;
    var runNextFrame = false;
    var isProcessing = false;
    var frame = {
        delta: 0,
        timestamp: 0,
    };
    var stepsOrder = [
>>>>>>> d52127c60da7f6ce492aebad9fb090b9de13f97b
        "read",
        "update",
        "preRender",
        "render",
        "postRender",
    ];
<<<<<<< HEAD
    const steps = stepsOrder.reduce((acc, key) => {
        acc[key] = createRenderStep(() => (runNextFrame = true));
        return acc;
    }, {});
    const sync = stepsOrder.reduce((acc, key) => {
        const step = steps[key];
        acc[key] = (process, keepAlive = false, immediate = false) => {
=======
    var steps = stepsOrder.reduce(function (acc, key) {
        acc[key] = createRenderStep(function () { return (runNextFrame = true); });
        return acc;
    }, {});
    var sync = stepsOrder.reduce(function (acc, key) {
        var step = steps[key];
        acc[key] = function (process, keepAlive, immediate) {
            if (keepAlive === void 0) { keepAlive = false; }
            if (immediate === void 0) { immediate = false; }
>>>>>>> d52127c60da7f6ce492aebad9fb090b9de13f97b
            if (!runNextFrame)
                startLoop();
            return step.schedule(process, keepAlive, immediate);
        };
        return acc;
    }, {});
<<<<<<< HEAD
    const cancelSync = stepsOrder.reduce((acc, key) => {
        acc[key] = steps[key].cancel;
        return acc;
    }, {});
    const flushSync = stepsOrder.reduce((acc, key) => {
        acc[key] = () => steps[key].process(frame);
        return acc;
    }, {});
    const processStep = (stepId) => steps[stepId].process(frame);
    const processFrame = (timestamp) => {
=======
    var cancelSync = stepsOrder.reduce(function (acc, key) {
        acc[key] = steps[key].cancel;
        return acc;
    }, {});
    var flushSync = stepsOrder.reduce(function (acc, key) {
        acc[key] = function () { return steps[key].process(frame); };
        return acc;
    }, {});
    var processStep = function (stepId) { return steps[stepId].process(frame); };
    var processFrame = function (timestamp) {
>>>>>>> d52127c60da7f6ce492aebad9fb090b9de13f97b
        runNextFrame = false;
        frame.delta = useDefaultElapsed
            ? defaultTimestep
            : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);
        frame.timestamp = timestamp;
        isProcessing = true;
        stepsOrder.forEach(processStep);
        isProcessing = false;
        if (runNextFrame) {
            useDefaultElapsed = false;
            onNextFrame(processFrame);
        }
    };
<<<<<<< HEAD
    const startLoop = () => {
=======
    var startLoop = function () {
>>>>>>> d52127c60da7f6ce492aebad9fb090b9de13f97b
        runNextFrame = true;
        useDefaultElapsed = true;
        if (!isProcessing)
            onNextFrame(processFrame);
    };
<<<<<<< HEAD
    const getFrameData = () => frame;
=======
    var getFrameData = function () { return frame; };
>>>>>>> d52127c60da7f6ce492aebad9fb090b9de13f97b

    exports.cancelSync = cancelSync;
    exports.default = sync;
    exports.flushSync = flushSync;
    exports.getFrameData = getFrameData;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
