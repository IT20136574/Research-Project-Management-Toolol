<<<<<<< HEAD
import { __awaiter } from "tslib";
import sync, { cancelSync, flushSync } from "../";
import { onNextFrame } from "../on-next-frame";
describe("onNextFrame", () => {
    it("fires callback on following frame", () => {
        return new Promise((resolve) => onNextFrame(resolve));
    });
});
describe("sync", () => {
    it("fires callbacks in the correct order", () => {
        return new Promise((resolve, reject) => {
            const order = [];
            sync.read(() => order.push(0));
            sync.update(() => order.push(1));
            sync.preRender(() => order.push(2));
            sync.render(() => order.push(3));
            sync.postRender(() => {
=======
import sync, { cancelSync } from "../";
import { onNextFrame } from "../on-next-frame";
describe("onNextFrame", function () {
    it("fires callback on following frame", function () {
        return new Promise(function (resolve) { return onNextFrame(resolve); });
    });
});
describe("sync", function () {
    it("fires callbacks in the correct order", function () {
        return new Promise(function (resolve, reject) {
            var order = [];
            sync.read(function () { return order.push(0); });
            sync.update(function () { return order.push(1); });
            sync.preRender(function () { return order.push(2); });
            sync.render(function () { return order.push(3); });
            sync.postRender(function () {
>>>>>>> d52127c60da7f6ce492aebad9fb090b9de13f97b
                order.push(4);
                if (order[0] === 0 &&
                    order[1] === 1 &&
                    order[2] === 2 &&
                    order[3] === 3 &&
                    order[4] === 4) {
                    resolve();
                }
                else {
                    reject(order);
                }
            });
        });
    });
<<<<<<< HEAD
    it("cancels callbacks", () => {
        return new Promise((resolve, reject) => {
            let hasFired = false;
            const process = sync.render(() => (hasFired = true));
            sync.update(() => cancelSync.render(process));
            sync.postRender(() => (hasFired ? reject(hasFired) : resolve()));
        });
    });
    it("fires callback on current frame if scheduled with `true` within the same step", () => {
        return new Promise((resolve, reject) => {
            let v = 0;
            sync.update(({ timestamp: prevTimestamp }) => {
                v++;
                sync.update(({ timestamp }) => {
                    v++;
                    if (timestamp !== prevTimestamp) {
                        reject(`${timestamp} ${prevTimestamp}`);
                    }
                }, false, true);
            });
            sync.render(() => (v === 2 ? resolve() : reject(v)));
        });
    });
    it("fires callback on next frame if scheduled with `true` outside the same step", () => {
        return new Promise((resolve, reject) => {
            let v = 0;
            sync.update(() => v++);
            sync.update(() => v++, false, true);
            sync.render(() => (v === 2 ? resolve() : reject()));
        });
    });
    it("uses default elapsed time if first fire", () => {
        return new Promise((resolve, reject) => {
            sync.update(({ delta: defaultElapsed }) => {
                setTimeout(() => sync.update(({ delta }) => delta === defaultElapsed
                    ? resolve()
                    : reject(defaultElapsed, delta)), 50);
            });
        });
    });
    it("correctly cancels", () => {
        return new Promise((resolve, reject) => {
            const callback = () => reject();
            sync.read(() => cancelSync.update(callback));
            sync.update(callback);
            sync.render(() => resolve());
        });
    });
    it("correctly keeps alive", () => {
        return new Promise((resolve) => {
            let v = 0;
            sync.update(() => v++, true);
            sync.render(() => v === 2 && resolve(), true);
        });
    });
    it("correctly cancels a keepAlive process", () => {
        return new Promise((resolve, reject) => {
            let updateCount = 0;
            let renderCount = 0;
            const update = sync.update(() => {
=======
    it("cancels callbacks", function () {
        return new Promise(function (resolve, reject) {
            var hasFired = false;
            var process = sync.render(function () { return (hasFired = true); });
            sync.update(function () { return cancelSync.render(process); });
            sync.postRender(function () { return (hasFired ? reject(hasFired) : resolve()); });
        });
    });
    it("fires callback on current frame if scheduled with `true` within the same step", function () {
        return new Promise(function (resolve, reject) {
            var v = 0;
            sync.update(function (_a) {
                var prevTimestamp = _a.timestamp;
                v++;
                sync.update(function (_a) {
                    var timestamp = _a.timestamp;
                    v++;
                    if (timestamp !== prevTimestamp) {
                        reject(timestamp + " " + prevTimestamp);
                    }
                }, false, true);
            });
            sync.render(function () { return (v === 2 ? resolve() : reject(v)); });
        });
    });
    it("fires callback on next frame if scheduled with `true` outside the same step", function () {
        return new Promise(function (resolve, reject) {
            var v = 0;
            sync.update(function () { return v++; });
            sync.update(function () { return v++; }, false, true);
            sync.render(function () { return (v === 2 ? resolve() : reject()); });
        });
    });
    it("uses default elapsed time if first fire", function () {
        return new Promise(function (resolve, reject) {
            sync.update(function (_a) {
                var defaultElapsed = _a.delta;
                setTimeout(function () {
                    return sync.update(function (_a) {
                        var delta = _a.delta;
                        return delta === defaultElapsed
                            ? resolve()
                            : reject(defaultElapsed, delta);
                    });
                }, 50);
            });
        });
    });
    it("correctly cancels", function () {
        return new Promise(function (resolve, reject) {
            var callback = function () { return reject(); };
            sync.read(function () { return cancelSync.update(callback); });
            sync.update(callback);
            sync.render(function () { return resolve(); });
        });
    });
    it("correctly keeps alive", function () {
        return new Promise(function (resolve) {
            var v = 0;
            sync.update(function () { return v++; }, true);
            sync.render(function () { return v === 2 && resolve(); }, true);
        });
    });
    it("correctly cancels a keepAlive process", function () {
        return new Promise(function (resolve, reject) {
            var updateCount = 0;
            var renderCount = 0;
            var update = sync.update(function () {
>>>>>>> d52127c60da7f6ce492aebad9fb090b9de13f97b
                updateCount++;
                if (updateCount === 4)
                    cancelSync.update(update);
            }, true);
<<<<<<< HEAD
            sync.render(() => {
=======
            sync.render(function () {
>>>>>>> d52127c60da7f6ce492aebad9fb090b9de13f97b
                renderCount++;
                if (renderCount === 6) {
                    if (renderCount !== updateCount) {
                        resolve();
                    }
                    else {
                        reject([renderCount, updateCount]);
                    }
                }
            }, true);
        });
    });
<<<<<<< HEAD
    it("correctly keeps alive after a flush", () => __awaiter(void 0, void 0, void 0, function* () {
        const promise = new Promise((resolve) => {
            let v = 0;
            sync.update(() => {
                if (v === 2)
                    flushSync.update();
            }, true);
            sync.update(() => {
                v++;
                if (v > 6)
                    resolve(true);
            }, true);
        });
        flushSync.update();
        return expect(promise).resolves.toBe(true);
    }));
=======
>>>>>>> d52127c60da7f6ce492aebad9fb090b9de13f97b
});
//# sourceMappingURL=test.js.map